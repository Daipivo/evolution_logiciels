Index: ../TP2/tp2/target/maven-archiver/pom.properties
===================================================================
diff --git a/../TP2/tp2/target/maven-archiver/pom.properties b/../TP2/tp2/target/maven-archiver/pom.properties
deleted file mode 100644
--- a/../TP2/tp2/target/maven-archiver/pom.properties	(revision 947e0905ddc2e9c6ad3336dca93b6d5deb2ffad9)
+++ /dev/null	(revision 947e0905ddc2e9c6ad3336dca93b6d5deb2ffad9)
@@ -1,3 +0,0 @@
-artifactId=TP2
-groupId=org.example
-version=1.0-SNAPSHOT
Index: ../TP2/tp2/src/main/java/couplage/MainCouplage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package couplage;\r\n\r\n\r\nimport graph.CallGraph;\r\nimport graph.Pair;\r\nimport scala.util.parsing.combinator.testing.Str;\r\n\r\nimport javax.swing.*;\r\nimport java.io.IOException;\r\nimport java.util.*;\r\n\r\npublic class MainCouplage {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n\r\n        /*\r\n        Instance du projet courant\r\n         */\r\n\r\n        CallGraph graph = new CallGraph(\"/home/e20220012486/test/EauDuBidons/\");\r\n\r\n        Couplage couplage = new Couplage(graph);\r\n\r\n        // Affichage du graphe de couplage\r\n        DisplayWeightedGraph displayWeightedGraph = new DisplayWeightedGraph(couplage);\r\n        displayWeightedGraph.displayGraph();\r\n\r\n        /*\r\n        Instance utilisé pour le rapport\r\n         */\r\n        Map<Pair<String, String>, Double> weightedGraphExempleRapport = new HashMap<>();\r\n\r\n        double totalRelations = 8.00;\r\n\r\n        weightedGraphExempleRapport.put(new Pair<>(\"ClassA\", \"ClassB\"), 3.0/totalRelations);\r\n        weightedGraphExempleRapport.put(new Pair<>(\"ClassA\", \"ClassC\"), 2.0/totalRelations);\r\n        weightedGraphExempleRapport.put(new Pair<>(\"ClassB\", \"ClassC\"), 2.0/totalRelations);\r\n        weightedGraphExempleRapport.put(new Pair<>(\"ClassC\", \"ClassC\"), 1.0/totalRelations);\r\n\r\n        ClusteringHierarchique clusteringExempleRapport = new ClusteringHierarchique(weightedGraphExempleRapport);\r\n        System.out.println(clusteringExempleRapport);\r\n\r\n        ModuleIdentifier moduleIdentifier = new ModuleIdentifier(clusteringExempleRapport, weightedGraphExempleRapport, 0.2, 3);\r\n        System.out.println(moduleIdentifier);\r\n\r\n        /*\r\n        Instance présent sur le TP\r\n         */\r\n        Map<Pair<String, String>, Double> weightedGraphTP = new HashMap<>();\r\n\r\n        weightedGraphTP.put(new Pair<>(\"A\", \"C\"), 0.3913);\r\n        weightedGraphTP.put(new Pair<>(\"B\", \"D\"), 0.3043);\r\n        weightedGraphTP.put(new Pair<>(\"E\", \"C\"), 0.1304);\r\n        weightedGraphTP.put(new Pair<>(\"E\", \"A\"), 0.0435);\r\n        weightedGraphTP.put(new Pair<>(\"E\", \"D\"), 0.1304);\r\n\r\n\r\n        ClusteringHierarchique clusteringTP = new ClusteringHierarchique(weightedGraphTP);\r\n        // Affichage du dendrogramme de l'instance du TP\r\n        System.out.println(clusteringTP);\r\n\r\n        // Identification de modules sur le graphe du TP\r\n        ModuleIdentifier moduleIdentifierTP = new ModuleIdentifier(clusteringTP, weightedGraphTP, 0.2, 5);\r\n        System.out.println(moduleIdentifierTP);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../TP2/tp2/src/main/java/couplage/MainCouplage.java b/../TP2/tp2/src/main/java/couplage/MainCouplage.java
--- a/../TP2/tp2/src/main/java/couplage/MainCouplage.java	(revision 947e0905ddc2e9c6ad3336dca93b6d5deb2ffad9)
+++ b/../TP2/tp2/src/main/java/couplage/MainCouplage.java	(date 1699565681566)
@@ -17,7 +17,7 @@
         Instance du projet courant
          */
 
-        CallGraph graph = new CallGraph("/home/e20220012486/test/EauDuBidons/");
+        CallGraph graph = new CallGraph("C:\\Users\\Sandratra\\Desktop\\Projet M1 UM\\HAI712I - Ingénierie Logicielle\\TP4-EauDuBidon");
 
         Couplage couplage = new Couplage(graph);
 
Index: ../TP2/tp2/src/main/java/couplage/ClusteringHierarchique.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package couplage;\r\n\r\nimport graph.Pair;\r\n\r\nimport java.util.*;\r\n\r\npublic class ClusteringHierarchique {\r\n\r\n    private Map<Pair<String, String>, Double> weightedGraph;\r\n\r\n    private Set<Cluster> dendrogramme = new LinkedHashSet<>();\r\n\r\n\r\n    /**\r\n     * Constructeur de la classe ClusteringHierarchique.\r\n     *\r\n     * @param weightedGraph Le graphe pondéré de l'application.\r\n     */\r\n    public ClusteringHierarchique(Map<Pair<String, String>, Double> weightedGraph) {\r\n        this.weightedGraph = weightedGraph;\r\n        this.dendrogramme = clusteringHierarchique();\r\n    }\r\n\r\n    /**\r\n     * Ajoute un cluster s'il n'existe pas déjà.\r\n     *\r\n     * @param clusters Ensemble de clusters existants.\r\n     * @param vertex Le sommet pour vérifier / ajouter.\r\n     */\r\n    private void addClusterIfNotExists(Set<Cluster> clusters, String vertex) {\r\n        for (Cluster existingCluster : clusters) {\r\n            if (existingCluster.getClasses().contains(vertex)) {\r\n                return; // Le cluster avec ce sommet existe déjà\r\n            }\r\n        }\r\n        clusters.add(new Cluster(vertex)); // Ajoute un nouveau cluster si aucun match n'a été trouvé\r\n    }\r\n\r\n    /**\r\n     * Calcule le couplage entre deux clusters.\r\n     *\r\n     * @param c1 Le premier cluster.\r\n     * @param c2 Le deuxième cluster.\r\n     * @return Le couplage entre les clusters c1 et c2.\r\n     */\r\n    public double couplageBtwClusters(Cluster c1, Cluster c2){\r\n        Set<String> classesC1 = c1.getClasses();\r\n        Set<String> classesC2 = c2.getClasses();\r\n        double result = 0.00;\r\n\r\n        for (String class1 : classesC1) {\r\n            for (String class2 : classesC2) {\r\n                Pair<String, String> pair1 = new Pair<>(class1, class2);\r\n                Pair<String, String> pair2 = new Pair<>(class2, class1);\r\n                if(weightedGraph.containsKey(pair1)) {\r\n                    result += weightedGraph.get(pair1);\r\n                }\r\n                else if(weightedGraph.containsKey(pair2)) {\r\n                    result += weightedGraph.get(pair2);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Effectue un clustering hiérarchique et retourne un ensemble de clusters.\r\n     *\r\n     * @return Un ensemble représentant la dendrogramme de clusters.\r\n     */\r\n    private Set<Cluster> clusteringHierarchique() {\r\n        Set<Cluster> dendro = new LinkedHashSet<>();\r\n        Set<Cluster> clusters = new HashSet<>();\r\n\r\n        // Initialisez les clusters individuels\r\n        for (Pair<String, String> edge : weightedGraph.keySet()) {\r\n            addClusterIfNotExists(clusters, edge.getFirst());\r\n            addClusterIfNotExists(clusters, edge.getSecond());\r\n        }\r\n\r\n        dendro.addAll(clusters);\r\n\r\n        while (clusters.size() > 1) {\r\n            double couplageMax = -1;\r\n            Cluster clusterMax1 = null;\r\n            Cluster clusterMax2 = null;\r\n\r\n            List<Cluster> clusterList = new ArrayList<>(clusters);\r\n\r\n            for (int i = 0; i < clusterList.size() - 1; i++) {\r\n                for (int j = i + 1; j < clusterList.size(); j++) {\r\n                    double currentCouplage = couplageBtwClusters(clusterList.get(i), clusterList.get(j));\r\n                    if (currentCouplage > couplageMax) {\r\n                        couplageMax = currentCouplage;\r\n                        clusterMax1 = clusterList.get(i);\r\n                        clusterMax2 = clusterList.get(j);\r\n                    }\r\n                }\r\n            }\r\n\r\n            Cluster clusterMax = new Cluster(clusterMax1, clusterMax2);\r\n            clusters.remove(clusterMax1);\r\n            clusters.remove(clusterMax2);\r\n            clusters.add(clusterMax);\r\n            dendro.add(clusterMax);\r\n        }\r\n\r\n        return dendro;\r\n    }\r\n\r\n    public Set<Cluster> getDendrogramme(){\r\n        return dendrogramme;\r\n    }\r\n\r\n    /**\r\n     * Retourne une représentation sous forme de chaîne de la classe ClusteringHierarchique.\r\n     *\r\n     * @return une chaîne de caractères représentant l'objet ClusteringHierarchique.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(\"Clustering Hierarchique {\\n\\tDendrogramme :\\n\");\r\n\r\n        // Convertir le Set en List pour conserver l'ordre d'insertion\r\n        List<Cluster> clustersList = new ArrayList<>(dendrogramme);\r\n\r\n        // Parcourir la liste en sens inverse\r\n        for (int i = clustersList.size() - 1; i >= 0; i--) {\r\n            builder.append(\"\\t\\t\").append(clustersList.get(i)).append(\"\\n\");\r\n        }\r\n\r\n        builder.append(\"}\");\r\n        return builder.toString();\r\n    }\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../TP2/tp2/src/main/java/couplage/ClusteringHierarchique.java b/../TP2/tp2/src/main/java/couplage/ClusteringHierarchique.java
--- a/../TP2/tp2/src/main/java/couplage/ClusteringHierarchique.java	(revision 947e0905ddc2e9c6ad3336dca93b6d5deb2ffad9)
+++ b/../TP2/tp2/src/main/java/couplage/ClusteringHierarchique.java	(date 1699508943408)
@@ -133,7 +133,4 @@
         builder.append("}");
         return builder.toString();
     }
-
-
-
 }
Index: ../TP2/tp2/src/main/java/couplage/Couplage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package couplage;\r\n\r\nimport graph.CallGraph;\r\nimport graph.Pair;\r\n\r\nimport java.util.*;\r\n\r\npublic class Couplage {\r\n\r\n    private CallGraph graph;\r\n    private Map<Pair<String, String>, Double> weightedGraph;\r\n    private double totalCoupling;\r\n\r\n    /**\r\n     * Constructeur de la classe Couplage.\r\n     *\r\n     * @param graph Le graphe des appels à initialiser.\r\n     */\r\n    public Couplage(CallGraph graph){\r\n        this.graph = graph;\r\n        this.totalCoupling = graph.getNbrAretesIntern();\r\n        this.weightedGraph = computeWeightedGraph();\r\n    }\r\n\r\n    /**\r\n     * Calcule le graphe pondéré.\r\n     *\r\n     * @return Retourne un Map contenant des paires de classes et leur couplage pondéré.\r\n     */\r\n    public Map<Pair<String, String>, Double> computeWeightedGraph() {\r\n\r\n        Map<Pair<String, String>, Double> graphResult = new HashMap<>();\r\n        List<String> classes = new ArrayList<>(this.graph.getGraphIntern().keySet());\r\n\r\n        for(int i = 0; i<classes.size();i++){\r\n            double coupling = calculateCouplingBtwClasses(classes.get(i), classes.get(i));\r\n            graphResult.put(new Pair<>(classes.get(i), classes.get(i)), coupling);\r\n        }\r\n\r\n\r\n        for (int i = 0; i < classes.size() - 1; i++) {\r\n            for (int j = i + 1; j < classes.size(); j++) {\r\n\r\n                String cls1 = classes.get(i);\r\n                String cls2 = classes.get(j);\r\n\r\n                double coupling = calculateCouplingBtwClasses(cls1, cls2);\r\n\r\n                graphResult.put(new Pair<>(cls1, cls2), coupling);\r\n            }\r\n        }\r\n\r\n        return graphResult;\r\n    }\r\n\r\n    /**\r\n     * Calcule le couplage entre deux classes.\r\n     *\r\n     * @param class1 La première classe.\r\n     * @param class2 La deuxième classe.\r\n     * @return Retourne le couplage entre class1 et class2.\r\n     */\r\n    private double calculateCouplingBtwClasses(String class1, String class2) {\r\n\r\n        Map<String, List<String>> class1Methods = graph.getCalledMethodsInClasse(class1);\r\n        Map<String, List<String>> class2Methods = graph.getCalledMethodsInClasse(class2);\r\n\r\n\r\n        long couplingsFromCls1ToCls2 = 0;\r\n        for (Map.Entry<String, List<String>> entry : class1Methods.entrySet()) {\r\n            List<String> methods = entry.getValue();\r\n\r\n            for (String method : methods) {\r\n                if (method.startsWith(class2 + \":\")) {\r\n                    couplingsFromCls1ToCls2++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(class1.equals(class2)) {\r\n            return couplingsFromCls1ToCls2 / totalCoupling;\r\n        }\r\n\r\n        long couplingsFromCls2ToCls1 = 0;\r\n        for (Map.Entry<String, List<String>> entry : class2Methods.entrySet()) {\r\n            List<String> methods = entry.getValue();\r\n\r\n            for (String method : methods) {\r\n                if (method.startsWith(class1 + \":\")) {\r\n                    couplingsFromCls2ToCls1++;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\r\n        return ( couplingsFromCls1ToCls2 + couplingsFromCls2ToCls1 ) / totalCoupling;\r\n    }\r\n\r\n    /**\r\n     * Obtient le graphe pondéré.\r\n     *\r\n     * @return Retourne le graphe pondéré.\r\n     */\r\n    public Map<Pair<String, String>, Double> getWeightedGraph() {\r\n        return this.weightedGraph;\r\n    }\r\n\r\n    /**\r\n     * Retourne une représentation sous forme de chaîne de la classe Couplage.\r\n     *\r\n     * @return une chaîne de caractères représentant l'objet Couplage.\r\n     */\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        sb.append(\"Couplage {\\n\");\r\n        sb.append(\"\\tTotal Coupling: \").append(totalCoupling).append(\"\\n\");\r\n        sb.append(\"\\tWeighted Graph: \\n\");\r\n        for (Map.Entry<Pair<String, String>, Double> entry : weightedGraph.entrySet()) {\r\n            sb.append(\"\\t\\t\").append(entry.getKey()).append(\" -> \").append(entry.getValue()).append(\"\\n\");\r\n        }\r\n        sb.append(\"}\");\r\n\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../TP2/tp2/src/main/java/couplage/Couplage.java b/../TP2/tp2/src/main/java/couplage/Couplage.java
--- a/../TP2/tp2/src/main/java/couplage/Couplage.java	(revision 947e0905ddc2e9c6ad3336dca93b6d5deb2ffad9)
+++ b/../TP2/tp2/src/main/java/couplage/Couplage.java	(date 1699893520281)
@@ -61,7 +61,7 @@
      * @return Retourne le couplage entre class1 et class2.
      */
     private double calculateCouplingBtwClasses(String class1, String class2) {
-
+        System.out.println("Total Coupling: "+totalCoupling);
         Map<String, List<String>> class1Methods = graph.getCalledMethodsInClasse(class1);
         Map<String, List<String>> class2Methods = graph.getCalledMethodsInClasse(class2);
 
